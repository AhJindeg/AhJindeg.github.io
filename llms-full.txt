# Hello World



Welcome to the docs! You can start writing documents in `/content/docs`.


# 关于 JSON 序列化与反序列化那些事



## JSON.stringify：格式化

* JSON.stringify 内有 ***格式化*** 程序。
* JSON.stringify(user, null, 2) 设置格式为 2 个缩进空格，也可以通过 第三个参数 定义缩进的内容。

## JSON.stringify：隐藏 字符串化数据中的 属性

* JSON.stringify 第二个参数被称为 ***replacer***。
* 它是一个 函数(不保留) 或 数组(保留)，用于决定数据 保留 或 不保留 在输出中。

```javascript
# 隐藏password用户
JSON.stringify(user, (key, value) = {
  if (key === 'password') return
  return value;
})

# 重构
function stripKeys(...keys) {
  return (key, value) = {
    if (keys.includes(key)) return
    return value;
  };
}
JSON.stringify(user, stripKeys('password', 'gender'))

# 还可以传递一个数组来仅获取某些键
JSON.stringify(user, ['name', 'age'])
```

## JSON.stringify：使用 toJSON 创建自定义输出格式

* 如果一个对象实现了该 ***toJSON*** 函数，JSON.stringify 将使用它来对数据进行字符串化。

```javascript
class Fraction {
  constructor(n, d) {
    this.numerator = n;
    this.denominator = d;
 }
}
JSON.stringify(new Fraction(1, 2))

# 如果我们想用一个字符串替换它1/2
class Fraction {
  constructor(n, d) {
    this.numerator = n;
    this.denominator = d;
  }
  toJSON() {
    return `${this.numerator}/${this.denominator}`
  }
}
JSON.stringify(new Fraction(1, 2))
```

## JSON.parse： 恢复数据

* 通过传递 第二个参数 JSON.parse 来指定 ***reviver*** 函数。
* 恢复器的工作是将字符串化数据 恢复 其原始形式。
* 我们传递了一个 reviver，它是类的静态 fromJSON 属性 Fraction。
* reviver 检查该值是否是一个合法的分数，如果是，它会创建一个新 Fraction 对象并返回它。

```javascript
class Fraction {
  constructor(n, d) {
    this.numerator = n
    this.denominator = d
  }
  toJSON() {
    return `${this.numerator}/${this.denominator}`
  }
  static fromJSON(key, value) {
    if (typeof value === 'string') {
      const parts = value.split('/').map(Number)
      if (parts.length === 2) return new Fraction(parts)
    }
    return value
  }
}
const fraction = new Fraction(1, 2)
const stringified = JSON.stringify(fraction)
// "1/2"
const revived = JSON.parse(stringified, Fraction.fromJSON)
```

* 此功能用于内置的 Date 对象。尝试查找 `Date.prototype.toJSON`。
* JSON.stringify(new Date())。
* 恢复日期，我们可以使用 JSON.parse。

```javascript
function reviveDate(key, value) {
  const regex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{1,}|)Z$/
  if (typeof value === 'string' && regex.test(value)) return new Date(value)
  return value
}
JSON.parse('"2022-03-01T06:28:41.308Z"', reviveDate)
```

## JSON.parse：使用 *revivers* 隐藏数据

* 与解析器一样，恢复器也可用于隐藏数据。它以相同的方式工作。

```javascript
const user = JSON.stringify( ... );
JSON.parse(user, (key, value) = {
    if (key === 'password') return;
    return value;
})
```


# 给 Window 增加自定义属性声明



## 给 Window 增加一个简单的类型声明

创建一个 `xxx.d.ts` 文件，使用 `declare` 声明类型 \<注意：此文件中不可以具有 `import` 等导入方法>

```typescript
<env.d.ts>

/// <reference types="vite/client" />

declare module '*.vue' {
  import { DefineComponent } from 'vue'
  const component: DefineComponent<{}, {}, any>
  export default component
}

declare interface Window {
  canvas: {
    e: boolean[],
    x: number,
    y: string
  }
}
```

## 给 Window 增加一个复杂的类型声明

因为在声明文件中使用 `import` 会导致被当作一个模块导致类型声明失效，如果我们要给 Window 增加一个已经声明好的类型就需要先创建一个文件用于定义全局命名空间，我们可以在命名空间中引入类型

创建 `xxx.d.ts` 文件 -> 创建命名空间 -> 在 Window 声明文件中使用命名空间定义的类型

```typescript
<window.d.ts>

import { CanvasPlus, Canvas } from '@/declare'

declare namespace WindowCanvas {
  interface CanvasInterface extends Canvas {
    canvas: CanvasPlus
  }
}

export = WindowCanvas
export as namespace WindowCanvas
```

```typescript
<env.d.ts>

/// <reference types="vite/client" />

declare module '*.vue' {
  import { DefineComponent } from 'vue'
  const component: DefineComponent<{}, {}, any>
  export default component
}

declare interface Window {
  windowCanvas: WindowCanvas.CanvasInterface
}
```


# 配置 prototype 防止往同一地址跳转时会报错的情况



#### 修改 VueRouter 配置 prototype 防止往同一地址跳转时会报错的情况

### router / index.js

```javascript
import Vue from 'vue'
import VueRouter from 'vue-router'

Vue.use(Router)

const originalPush = VueRouter.prototype.push
VueRouter.prototype.push = function push(location, onResolve, onReject) {
  if (onResolve || onReject)
    return originalPush.call(this, location, onResolve, onReject)
  return originalPush.call(this, location).catch((err) => err)
}

const originalReplace = VueRouter.prototype.receive
VueRouter.prototype.replace = function replace(location, onResolve, onReject) {
  if (onResolve || onReject)
    return originalReplace.call(this, location, onResolve, onReject)
  return originalReplace.call(this, location).catch((err) => err)
}
```


# 关于在 VUE3 中样式穿透的小建议



#### 使用 VUE3 项目后会因为使用的 CSS 预处理 不同导致`/deep/ & v-deep & >>>` 无效或者报错

可以修改为使用 `:deep(.className)`

设置 ***全局样式*** 使用 `:global(.className)`

设置 ***插槽样式*** 使用 `:slotted(.className)`
