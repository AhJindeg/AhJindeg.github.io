import{_ as e,o as a,c as t,a as n}from"./app-X7JQ3QX2.js";const r={},c=n(`<p><em>作者：Ethan_Zhou</em></p><p><em>链接：https://juejin.cn/post/7213362932423376933</em></p><h2 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h2><p>写异步函数的时候，promise 和 async 两种方案都非常常见，甚至同一个项目里，不同的开发人员都使用不同的习惯, 不过关于两者的比较不是本文关注的重点，只总结为一句话：“async 是异步编程的终极解决方案”。</p><p>当使用 async 函数的时候，很多文章都说建议用 <code>try catch</code> 来捕获异常, 可是实际上我看了很多项目的代码，遵循的并不是严谨，很多都没有用，甚至 catch 函数都没写，这是为什么呢？</p><p>我们先看下使用 try catch 情况下的代码示例：</p><h2 id="示例1-使用-try-catch" tabindex="-1"><a class="header-anchor" href="#示例1-使用-try-catch" aria-hidden="true">#</a> 示例1 ：使用 try catch</h2><div class="language-auto line-numbers-mode" data-ext="auto"><pre class="language-auto"><code>function getUserInfo () {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {                reject(&#39;请求异常&#39;)        }, 1000)    })}async function logined () {    try {        let userInfo = await getUserInfo()        // 执行中断        let pageInfo = await getPageInfo(userInfo?.userId)    } catch(e) {        console.warn(e)    }}logined()
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行后会在 catch 里捕获 <code>请求异常</code>，然后 getUserInfo 函数中断执行，这是符合逻辑的，对于有依赖关系的接口，中断执行可以避免程序崩溃，这里唯一的问题是 try catch 貌似占据了太多行数，如果每个接口都写的话看起来略显冗余。</p><h2 id="示例2-直接-catch" tabindex="-1"><a class="header-anchor" href="#示例2-直接-catch" aria-hidden="true">#</a> 示例2：直接 catch</h2><p>鉴于正常情况下，<code>await</code> 命令后面是一个 Promise 对象, 所以上面代码可以很自然的想到优化方案：</p><div class="language-auto line-numbers-mode" data-ext="auto"><pre class="language-auto"><code>function getUserInfo () {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {                reject(&#39;请求异常&#39;)        }, 1000)    })}async function logined () {    let userInfo = await getUserInfo().catch(e =&gt; console.warn(e))    // 执行没有中断，userInfo 为 undefined    if (!userInfo) return // 需要做非空校验    let pageInfo = await getPageInfo(userInfo?.userId)}logined()
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行后 catch 可以正常捕获异常，但是程序没有中断，返回值 <code>userInfo</code> 为 <code>undefined</code>, 所以如果这样写的话，就需要对返回值进行非空校验, <code>if (!userInfo) return</code> 我觉得这样有点反逻辑，异常时就应该中断执行才对；</p><h2 id="示例3-在-catch-里-reject" tabindex="-1"><a class="header-anchor" href="#示例3-在-catch-里-reject" aria-hidden="true">#</a> 示例3：在 catch 里 reject</h2><p>可以继续优化，在 catch 里面加一行 <code>return Promise.reject(e)</code>, 可以使 await 中断执行；</p><p>完整代码：</p><div class="language-auto line-numbers-mode" data-ext="auto"><pre class="language-auto"><code>function getUserInfo () {    return new Promise((resolve, reject) =&gt; {        setTimeout(() =&gt; {            reject(&#39;请求异常&#39;)        }, 1000)    })}async function logined () {    let userInfo = await getUserInfo().catch(e =&gt; {        console.warn(e)        return Promise.reject(e) // 会导致控制台出现 uncaught (in promise) 报错信息    })    // 执行中断    let pageInfo = await getPageInfo(userInfo?.userId)}logined()
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>一般我们在项目里都是用 axios 或者 fetch 之类发送请求，会对其进行一个封装，也可以在里面进行 catch 操作，对错误信息先一步处理，至于是否需要 reject，就看你是否想要在 await 命令异常时候中断了；不使用 reject 则不会中断，但是需要每个接口拿到 response 后先 非空校验， 使用 reject 则会在异常处中断，并且会在控制台暴露 <code>uncaught (in promise)</code> 报错信息。</p><p>![图片](data:image/svg+xml,%3C%3Fxml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;%3F%3E%3Csvg width=&#39;1px&#39; height=&#39;1px&#39; viewBox=&#39;0 0 1 1&#39; version=&#39;1.1&#39; xmlns=&#39;http://www.w3.org/2000/svg&#39; xmlns:xlink=&#39;http://www.w3.org/1999/xlink&#39;%3E%3Ctitle%3E%3C/title%3E%3Cg stroke=&#39;none&#39; stroke-width=&#39;1&#39; fill=&#39;none&#39; fill-rule=&#39;evenodd&#39; fill-opacity=&#39;0&#39;%3E%3Cg transform=&#39;translate(-249.000000, -126.000000)&#39; fill=&#39;%23FFFFFF&#39;%3E%3Crect x=&#39;249&#39; y=&#39;126&#39; width=&#39;1&#39; height=&#39;1&#39;%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)</p><h2 id="建议" tabindex="-1"><a class="header-anchor" href="#建议" aria-hidden="true">#</a> 建议</h2><p>不需要在 await 处异常时中断，可以这样写，需要做非空校验，控制台不会有报错信息</p><div class="language-auto line-numbers-mode" data-ext="auto"><pre class="language-auto"><code>let userInfo = await getUserInfo().catch(e =&gt; console.warn(e))if (!userInfo) return
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>需要在 await 处异常时中断，并且在意控制台报错，可以这样写</p><div class="language-auto line-numbers-mode" data-ext="auto"><pre class="language-auto"><code>try {    let userInfo = await getUserInfo()    // 执行中断    let pageInfo = await getPageInfo(userInfo?.userId)} catch(e) {    console.warn(e)}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>需要在 await 处异常时中断，但是不在意控制台报错，则可以这样写</p><div class="language-auto line-numbers-mode" data-ext="auto"><pre class="language-auto"><code>let userInfo = await getUserInfo().catch(e =&gt; {    console.warn(e)    return Promise.reject(e) // 会导致控制台出现 uncaught (in promise) 报错信息})// 执行中断let pageInfo = await getPageInfo(userInfo?.userId)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>几种写法，初看可能觉得第三种 catch 这种写法是最好的，但是细想下，从用户体验上来看，我觉得 try catch 是最好的，逻辑直观、符合同步编程思维，控制台不会暴露 <code>uncaught (in promise)</code> 报错信息；</p><p>而链式调用的 catch (里面再 reject)，是传统 promise 的回调写法，既然已经用 async await 这种同步编程写法了，再用 catch 链式写法，感觉没必要。</p>`,29),i=[c];function o(s,d){return a(),t("div",null,i)}const l=e(r,[["render",o],["__file","async_await hanshudaodiyaobuyaojia try catch _.html.vue"]]);export{l as default};
