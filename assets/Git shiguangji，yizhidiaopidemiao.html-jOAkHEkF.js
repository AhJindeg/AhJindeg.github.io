import{_ as t,r as o,o as c,c as i,b as e,d as n,e as s,a as l}from"./app-ojJIz5WI.js";const r={},d=e("h2",{id:"前言",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#前言","aria-hidden":"true"},"#"),n(" 前言")],-1),p=e("code",null,"Git",-1),m={href:"https://github.com/slshsl/articles/blob/main/src/2023/2023-03-14-GIt%E6%97%B6%E5%85%89%E6%9C%BA%EF%BC%88%E7%AE%80%E5%8D%95%E5%B0%8F%E4%BE%8B%E5%AD%90%EF%BC%89/2023-03-14-GIt%E6%97%B6%E5%85%89%E6%9C%BA%EF%BC%88%E7%AE%80%E5%8D%95%E5%B0%8F%E4%BE%8B%E5%AD%90%EF%BC%89.md",target:"_blank",rel:"noopener noreferrer"},u=l(`<h2 id="git-与其他版本控制系统的区别" tabindex="-1"><a class="header-anchor" href="#git-与其他版本控制系统的区别" aria-hidden="true">#</a> Git 与其他版本控制系统的区别</h2><p><code>Git</code> 直接记录<strong>快照</strong>，而非<strong>差异</strong>比较。</p><h2 id="git-完整性" tabindex="-1"><a class="header-anchor" href="#git-完整性" aria-hidden="true">#</a> Git 完整性</h2><p><code>Git</code> 中所有的数据在存储前都计算校验和，然后以<strong>校验和</strong>来<strong>引用</strong>。<code>Git</code> 用以计算校验和的机制叫做 <strong>SHA-1</strong> 散列（<code>hash</code>，哈希）。</p><h2 id="git-如何存储数据" tabindex="-1"><a class="header-anchor" href="#git-如何存储数据" aria-hidden="true">#</a> Git 如何存储数据</h2><p>Git 存储数据有点像 <code>key-value store</code>，<code>key</code>可以认为是<code>data</code>的<code>sha1</code>哈希，<code>value</code>认为是数据本身。</p><blockquote><p>💡value 是经过 ZLib 压缩过的</p></blockquote><h2 id="git-基础概念" tabindex="-1"><a class="header-anchor" href="#git-基础概念" aria-hidden="true">#</a> Git 基础概念</h2><p><code>Working Space / Working Directory</code>： <strong>工作区/工作目录</strong>，就是你平时存放项目代码的地方，本文统一使用<strong>工作区</strong></p><p><code>Index / Stage</code>： <strong>暂存区/索引区</strong>，用于临时存放你的改动，本文统一使用<strong>暂存区</strong></p><p><code>Local Repository</code>： <strong>本地仓库</strong>（<strong>本地版本库</strong>）本文统一使用<strong>本地仓库</strong></p><p><code>Stash</code>：<strong>贮藏区</strong></p><p><code>Remote Repository</code> ： <strong>远程仓库</strong>（<strong>远程版本库</strong>）本文统一使用<strong>远程仓库</strong></p><p><code>&lt;remote_name&gt;/&lt;branch_name&gt;</code>：<strong>本地远程分支引用/本地远程跟踪分支</strong>，本文统一使用<strong>本地远程跟踪分支</strong></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd67139f6fb84c828774a5b34294b709~tplv-k3u1fbpfcp-watermark.image?" alt="1.drawio.export.png"></p><h2 id="常用指令" tabindex="-1"><a class="header-anchor" href="#常用指令" aria-hidden="true">#</a> 常用指令</h2><h3 id="git-xxx-h" tabindex="-1"><a class="header-anchor" href="#git-xxx-h" aria-hidden="true">#</a> git xxx -h</h3><p>查看某个指令的帮助信息。</p><h3 id="git-config" tabindex="-1"><a class="header-anchor" href="#git-config" aria-hidden="true">#</a> git config</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看git配置</span>
$ <span class="token function">git</span> config -l\`
<span class="token comment"># 查看系统配置</span>
$ <span class="token function">git</span> config <span class="token parameter variable">--system</span> <span class="token parameter variable">--list</span>
<span class="token comment"># 查看用户配置</span>
$ <span class="token function">git</span> config <span class="token parameter variable">--global</span> <span class="token parameter variable">--list</span>
<span class="token comment"># 查看项目配置</span>
$ <span class="token function">git</span> config <span class="token parameter variable">--local</span> <span class="token parameter variable">--list</span>
<span class="token comment"># 设置用户名称</span>
$ <span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name xxx
<span class="token comment"># 设置用户邮箱</span>
$ <span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email xxx
<span class="token comment"># 启动的编辑器一般为 vim。 当然也可以命令设置你喜欢的编辑器。</span>
<span class="token comment"># 我一般习惯设置成vscode</span>
$ <span class="token function">git</span> config <span class="token parameter variable">--global</span> core.editor xxx
<span class="token comment"># 项目启用rerere</span>
$ <span class="token function">git</span> config rerere.enabled <span class="token boolean">true</span>
<span class="token comment"># 设置log -1 HEAD的别名为last</span>
$ <span class="token function">git</span> config <span class="token parameter variable">--global</span> alias.last <span class="token string">&#39;log -1 HEAD&#39;</span>
<span class="token comment"># 使用last别名</span>
$ <span class="token function">git</span> last
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>💡 每一个级别会覆盖上一级别的配置</p></blockquote><h3 id="git-init" tabindex="-1"><a class="header-anchor" href="#git-init" aria-hidden="true">#</a> git init</h3><p>初始化一个仓库。</p><h3 id="git-clone" tabindex="-1"><a class="header-anchor" href="#git-clone" aria-hidden="true">#</a> git clone</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 克隆一个仓库</span>
$ <span class="token function">git</span> clone <span class="token operator">&lt;</span>url<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>💡<code>git clone</code> 命令做了什么？</p></blockquote><ol><li>添加一个跟踪的远程仓库<code>remote</code>，自动将其命名为 <code>origin</code>，拉取它的所有数据</li><li>创建一个<code>origin/master</code>（<strong>本地远程跟踪分支</strong>）</li><li>创建一个 <code>master</code> （<strong>本地分支</strong>）</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 克隆一个仓库</span>
$ <span class="token function">git</span> clone —depth<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">&lt;</span>url<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>通常我们直接使用 <code>git clone</code> 即可克隆项目，如果只是使用一个仓库项目，这是加入  <strong>–depth=1</strong>参数可以使我们只下载当前的最新提交即可。</p><h3 id="git-add" tabindex="-1"><a class="header-anchor" href="#git-add" aria-hidden="true">#</a> git add</h3><p>添加工作区的内容至索引区。</p><h3 id="git-status" tabindex="-1"><a class="header-anchor" href="#git-status" aria-hidden="true">#</a> git status</h3><p>显示当前的状态。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">git</span> status
On branch dev
Your branch is ahead of <span class="token string">&#39;origin/dev&#39;</span> by <span class="token number">2</span> commits.
  <span class="token punctuation">(</span>use <span class="token string">&quot;git push&quot;</span> to publish your <span class="token builtin class-name">local</span> commits<span class="token punctuation">)</span>

Changes to be committed:
  <span class="token punctuation">(</span>use <span class="token string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage<span class="token punctuation">)</span>
        modified:   a.txt

Changes not staged <span class="token keyword">for</span> commit:
  <span class="token punctuation">(</span>use <span class="token string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed<span class="token punctuation">)</span>
  <span class="token punctuation">(</span>use <span class="token string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>
        modified:   a.txt

Untracked files:
  <span class="token punctuation">(</span>use <span class="token string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="token keyword">in</span> what will be committed<span class="token punctuation">)</span>
        c.txt
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>显示当前分支与其本地远程跟踪分支（如果有）的关系 可以通过<code>git push</code>推到远程的 commit</li><li>显示暂存区和本地仓库有差异的文件 通过运行<code>git commit</code>会添加到本地仓库的文件</li><li>显示工作区和暂存区有差异的文件 通过运行<code>git add</code>可以添加到暂存区的文件</li><li>显示工作区中不被<code>git</code>追踪的文件（也不被<code>.gitignore</code>忽略） 通过运行<code>git add</code>可以添加到暂存区的文件</li></ol><h3 id="git-commit" tabindex="-1"><a class="header-anchor" href="#git-commit" aria-hidden="true">#</a> git commit</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 提交变更到本地仓库</span>
$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">&quot;xxx&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 修补提交：修补最后的提交</span>
$ <span class="token function">git</span> commit <span class="token parameter variable">--amend</span>
<span class="token comment"># 修补提交：修补最后的提交，不修改提交信息</span>
$ <span class="token function">git</span> commit <span class="token parameter variable">--amend</span> --no-edit
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ea4827ab18747b4ba2663f509baab49~tplv-k3u1fbpfcp-watermark.image?" alt="1.amend.drawio.export.png"></p><blockquote><p>💡<code>git commit --amend</code>：修补最后的提交时，是完全用一个新的提交替换旧的提交。修补提交最明显的价值是可以稍微改进你最后的提交，例如一些小的修补，笔误等等；可以像下面这样操作：</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 第一次提交</span>
$ <span class="token function">git</span> commit <span class="token parameter variable">-m</span> <span class="token string">&#39;initial commit&#39;</span>
<span class="token comment"># 修改笔误等</span>
$ <span class="token function">git</span> <span class="token function">add</span> forgotten_file
<span class="token comment"># 第二次提交</span>
$ <span class="token function">git</span> commit <span class="token parameter variable">--amend</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>💡 最终你只会有一个提交；第二次提交将代替第一次提交的结果。</p></blockquote><blockquote><p>💡 假如你的代码已经 <code>push</code> 了的话，<code>git commit --amend</code>要慎用，因为会修改提交历史。</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 带签名的提交</span>
<span class="token function">git</span> commit <span class="token parameter variable">--signoff</span> <span class="token parameter variable">-m</span> <span class="token string">&#39;xxxx&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="git-log" tabindex="-1"><a class="header-anchor" href="#git-log" aria-hidden="true">#</a> git log</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 基本用法</span>
$ <span class="token function">git</span> log
<span class="token comment"># 仅显示最近的 n 条提交</span>
$ <span class="token function">git</span> log -<span class="token operator">&lt;</span>n<span class="token operator">&gt;</span>
<span class="token comment"># 按补丁格式显示每个提交引入的差异</span>
$ <span class="token function">git</span> log <span class="token parameter variable">-p</span>
<span class="token comment"># 显示每次提交的文件修改统计信息</span>
$ <span class="token function">git</span> log <span class="token parameter variable">--stat</span>
<span class="token comment"># 在日志旁以 ASCII 图形显示分支与合并历史</span>
$ <span class="token function">git</span> log <span class="token parameter variable">--graph</span>
<span class="token comment"># 每条日志一行显示</span>
$ <span class="token function">git</span> log <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline
<span class="token comment"># 仅显示 SHA-1 校验和所有 40 个字符中的前几个字符</span>
$ <span class="token function">git</span> log --abbrev-commit
<span class="token comment"># --pretty=oneline --abbrev-commit 合用的简写。</span>
$ <span class="token function">git</span> log <span class="token parameter variable">--oneline</span>
<span class="token comment"># 仅显示作者匹配指定字符串的提交。</span>
$ <span class="token function">git</span> log <span class="token parameter variable">--author</span><span class="token operator">=</span><span class="token string">&#39;xxx&#39;</span>
<span class="token comment">#</span>
$ <span class="token function">git</span> --no-pager log
<span class="token comment"># Log files that have been moved or renamed</span>
$ <span class="token function">git</span> log --name-status <span class="token parameter variable">--follow</span> -- <span class="token function">file</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="git-diff" tabindex="-1"><a class="header-anchor" href="#git-diff" aria-hidden="true">#</a> git diff</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 比较工作区与暂存区之间的差别</span>
$ <span class="token function">git</span> <span class="token function">diff</span>
<span class="token comment"># 比较暂存区与本地仓库之间的差别</span>
$ <span class="token function">git</span> <span class="token function">diff</span> —cached（git <span class="token function">diff</span> —staged）
<span class="token comment"># 比较工作区和暂存区（即所有未提交到本地仓库的修改）与本地仓库当前的HEAD之间的差别</span>
$ <span class="token function">git</span> <span class="token function">diff</span> HEAD
<span class="token comment"># 比较工作区和暂存区（即所有未提交到本地仓库的修改）与本地仓库dev分支最新commit之间的差别</span>
$ <span class="token function">git</span> <span class="token function">diff</span> dev
<span class="token comment"># 比较工作区和暂存区（即所有未提交到本地仓库的修改）与本地远程跟踪dev分支最新commit之间的差别</span>
$ <span class="token function">git</span> <span class="token function">diff</span> origin/master
<span class="token comment"># 比较两次提交之间的差别</span>
$ <span class="token function">git</span> <span class="token function">diff</span> <span class="token punctuation">[</span>commit_sha1_value<span class="token punctuation">]</span> <span class="token punctuation">[</span>commit_sha1_value<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="git-tag" tabindex="-1"><a class="header-anchor" href="#git-tag" aria-hidden="true">#</a> git tag</h3><p>有两种 tag，一种是<strong>lightweight</strong>，<strong>轻量标签</strong>；一种是<strong>annotated tag</strong>，<strong>附注标签</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 显示所有</span>
$ <span class="token function">git</span> tag
<span class="token comment"># 创建lightweight tag（轻量标签）</span>
<span class="token comment"># 如果没有写commit_sha1_value，则会自动把tag放到目前的这个commit上</span>
$ <span class="token function">git</span> tag <span class="token operator">&lt;</span>tag_name<span class="token operator">&gt;</span> <span class="token punctuation">[</span>commit_sha1_value<span class="token punctuation">]</span>
<span class="token comment"># 创建annotated tag（附注标签）</span>
<span class="token comment"># 如果没有写commit_sha1_value，则会自动把tag放到目前的这个commit上</span>
$ <span class="token function">git</span> tag <span class="token parameter variable">-a</span> <span class="token operator">&lt;</span>tag_name<span class="token operator">&gt;</span> <span class="token parameter variable">-m</span> <span class="token operator">&lt;</span>tag_message<span class="token operator">&gt;</span> <span class="token punctuation">[</span>commit_sha1_value<span class="token punctuation">]</span>
<span class="token comment"># 删除tag</span>
$ <span class="token function">git</span> tag <span class="token parameter variable">-d</span> <span class="token operator">&lt;</span>tag_name<span class="token operator">&gt;</span>
<span class="token comment"># 查看某个commit上的标签</span>
$ <span class="token function">git</span> tag --points-at <span class="token operator">&lt;</span>commit<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>💡<strong>轻量标签</strong>很像一个不会改变的分支——它只是某个特定提交的<strong>引用</strong>。</p></blockquote><blockquote><p>💡<strong>附注标签</strong>是存储在 <code>Git</code> 数据库中的一个完整<strong>git 的 tag 类型的 objects</strong>对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息。</p></blockquote><h3 id="git-show" tabindex="-1"><a class="header-anchor" href="#git-show" aria-hidden="true">#</a> git show</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 显示tag对应的commit所提交的内容，如果是附注标签，还是显示附注标签的信息</span>
$ <span class="token function">git</span> show <span class="token operator">&lt;</span>tag_name<span class="token operator">&gt;</span>
<span class="token comment"># 显示某次commit提交的内容</span>
$ <span class="token function">git</span> show <span class="token operator">&lt;</span>commit_sha1_value<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="git-branch" tabindex="-1"><a class="header-anchor" href="#git-branch" aria-hidden="true">#</a> git branch</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看本地仓库分支</span>
$ <span class="token function">git</span> branch
<span class="token comment"># 查看远程仓库分支</span>
$ <span class="token function">git</span> branch <span class="token parameter variable">-r</span>
<span class="token comment"># 查看本地仓库和远程仓库分支</span>
$ <span class="token function">git</span> branch <span class="token parameter variable">-a</span>
<span class="token comment"># 创建本地仓库分支</span>
$ <span class="token function">git</span> branch <span class="token operator">&lt;</span>branch_name<span class="token operator">&gt;</span>
<span class="token comment"># 强制删除本地仓库分支</span>
$ <span class="token function">git</span> branch <span class="token parameter variable">-D</span> <span class="token operator">&lt;</span>branch_name<span class="token operator">&gt;</span>
<span class="token comment"># 删除本地仓库分支</span>
$ <span class="token function">git</span> branch <span class="token parameter variable">-d</span> <span class="token operator">&lt;</span>branch_name<span class="token operator">&gt;</span>
<span class="token comment"># 查看分支详细信息，包括分支最后一个commit的hash、message等</span>
$ <span class="token function">git</span> branch <span class="token parameter variable">-v</span>
<span class="token comment"># 同git branch -v</span>
$ <span class="token function">git</span> branch <span class="token parameter variable">-vv</span>
<span class="token comment"># 修改本地仓库分支名称，如果省略old_branch_name，则更改的是当前分支的名称</span>
$ <span class="token function">git</span> branch <span class="token parameter variable">-m</span> <span class="token operator">&lt;</span>old_branch_name<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>new_branch_name<span class="token operator">&gt;</span>
<span class="token comment"># 强制修改本地仓库分支名称</span>
$ <span class="token function">git</span> branch <span class="token parameter variable">-M</span> <span class="token operator">&lt;</span>old_branch_name<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>new_branch_name<span class="token operator">&gt;</span>
<span class="token comment"># 查看哪些分支已经合并到当前分支</span>
$ <span class="token function">git</span> branch <span class="token parameter variable">--merged</span>
<span class="token comment"># 查看哪些分支未合并到当前分支</span>
$ <span class="token function">git</span> branch --no-merged
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>💡<code>git branch -d &lt;branch_name&gt;</code>：<strong>如果该分支还未合入 master 或者 main，会提示报错，不让删除</strong></p></blockquote><blockquote><p>💡<code>git branch -vv</code>：<strong>同时还会显示每一个分支正在跟踪哪个远程分支</strong></p></blockquote><h3 id="git-checkout" tabindex="-1"><a class="header-anchor" href="#git-checkout" aria-hidden="true">#</a> git checkout</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 切换到新分支</span>
$ <span class="token function">git</span> checkout <span class="token operator">&lt;</span>branch_name<span class="token operator">&gt;</span>
<span class="token comment"># 创建并切换到新分支</span>
$ <span class="token function">git</span> checkout <span class="token parameter variable">-b</span> <span class="token operator">&lt;</span>branch_name<span class="token operator">&gt;</span>
<span class="token comment"># 重置分支，删除已存在的分支且重新创建，分支不存在也不会报错称</span>
$ <span class="token function">git</span> checkout <span class="token parameter variable">-B</span> <span class="token operator">&lt;</span>branch_name<span class="token operator">&gt;</span>
<span class="token comment"># 将head指向一个commit</span>
$ <span class="token function">git</span> checkout <span class="token operator">&lt;</span>commit_sha1_value<span class="token operator">&gt;</span>
<span class="token comment"># 从某个本地远程跟踪分支中检出一个新分支（并设置该分支的上游是远程跟踪分支）</span>
$ <span class="token function">git</span> checkout <span class="token parameter variable">-b</span> <span class="token operator">&lt;</span>new_branch_name<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>remote_name<span class="token operator">&gt;</span>/<span class="token operator">&lt;</span>old_branch_name<span class="token operator">&gt;</span>
<span class="token comment"># 是 git checkout -b &lt;new_branch_name&gt; &lt;remote_name&gt;/&lt;old_branch_name&gt;的简写</span>
$ <span class="token function">git</span> checkout <span class="token parameter variable">--track</span> <span class="token operator">&lt;</span>remote_name<span class="token operator">&gt;</span>/<span class="token operator">&lt;</span>branch_name<span class="token operator">&gt;</span>
<span class="token comment"># 让工作区中的所有文件撤销更改</span>
$ <span class="token function">git</span> checkout -- <span class="token builtin class-name">.</span>
<span class="token comment"># 让工作区中的某些文件撤销更改</span>
$ <span class="token function">git</span> checkout -- <span class="token operator">&lt;</span>file_name<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>file_name<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>💡 <code>git checkout -b &lt;new_branch_name&gt; &lt;remote_name&gt;/&lt;old_branch_nameh&gt;</code></p><p>💡 <code>git checkout --track &lt;remote_name&gt;/&lt;branch_name&gt;</code></p><p>💡 <code>git checkout &lt;branch_name&gt;</code></p><p><code>git checkout -b &lt;new_branch_name&gt; &lt;remote_name&gt;/&lt;old_branch_nameh&gt;</code>的意思是从某个本地远程跟踪分支中检出一个新分支，并设置该新分支的上游是该本地远程跟踪分支； 因为<code>git checkout -b &lt;new_branch_name&gt; &lt;remote_name&gt;/&lt;old_branch_nameh&gt;</code>经常用，且检出的新分支名字和其上游分支的名字一般相同，不太会取不同的名字；所以出了一个简写命令<code>git checkout --track &lt;remote_name&gt;/&lt;branch_name&gt;</code>； <code>git checkout --track &lt;remote_name&gt;/&lt;branch_name&gt;</code>该命令从某个本地远程跟踪分支中检出一个新分支，并设置该新分支的上游是该本地远程跟踪分支，同时该新分支的名字不能指定，只能是该本地远程跟踪分支的名字； <code>git checkout --track &lt;remote_name&gt;/&lt;branch_name&gt;</code>还是太长；所以 <code>git checkout branch_name</code> 切换分支时，先从本地库查找分支，在本地库没找到时，会去本地远程跟踪分支中查找，如果本地远程跟踪分支中有相同名称的分支，则也会检出分支并设置其上游为同名的本地远程跟踪分支；如果本地远程跟踪分支里也没有找到就会报错；</p></blockquote><blockquote><p>💡<code>git checkout &lt;commit_sha1_value&gt;</code>：这样会发生<strong>detached head</strong>,即<code>head</code>不再指向一个分支，而是指向一个<code>commit</code>； 应用场景是比如从之前的<code>commit</code>或者误删的<code>commit</code>(通过给<code>git reflog</code>查看)；拉出一个新分支；</p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看所有操作的日志</span>
$ <span class="token function">git</span> reflog
<span class="token comment"># 检出需要检出的commit</span>
$ <span class="token function">git</span> checkout <span class="token operator">&lt;</span>ommit_sha1_value<span class="token operator">&gt;</span>
<span class="token comment"># 检出一个新的分支</span>
$ <span class="token function">git</span> checkout <span class="token parameter variable">-b</span> <span class="token operator">&lt;</span>new_branch_name<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>💡<code>git checkout --</code>的撤销功能：<code>git checkout</code>撤销的是工作区的内容，即<strong>清除工作区</strong> 场景一、本地库中已有 <code>user.txt</code>，<strong>在工作区修改了该文件，但是没有提交到暂存区，此时撤销更改是从本地仓库中恢复内容</strong> 场景二、本地库中已有 <code>user.txt</code>，<strong>在工作区修改了该文件，并且之前按已提交到暂存区，此时撤销更改是从暂存区中恢复内容</strong></p></blockquote><h3 id="git-restore" tabindex="-1"><a class="header-anchor" href="#git-restore" aria-hidden="true">#</a> git restore</h3><p>替代<code>git checkout</code>的撤销功能。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 放弃在工作区的修改</span>
$ <span class="token function">git</span> restore <span class="token operator">&lt;</span>file_name<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>file_name<span class="token operator">&gt;</span>
<span class="token comment"># 放弃所有文件在工作区的修改</span>
$ <span class="token function">git</span> restore <span class="token builtin class-name">.</span>
<span class="token comment"># 将暂存区的内容，移动工作区中，即是git add的反向操作</span>
$ <span class="token function">git</span> restore  —staged <span class="token operator">&lt;</span>file_name<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>filen_ame<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>💡<code>git restore &lt;file_name&gt; &lt;file_name&gt;</code>替代<code>git checkout -- &lt;file_name&gt; &lt;file_name&gt;</code></p></blockquote><blockquote><p>💡<code>git restore .</code>替代<code>git checkout -- .</code></p></blockquote><blockquote><p>💡<code>it restore —staged &lt;file_name&gt; &lt;filen_ame&gt;</code>：<code>git add</code> 的反向操作</p></blockquote><h3 id="git-switch" tabindex="-1"><a class="header-anchor" href="#git-switch" aria-hidden="true">#</a> git switch</h3><p>替代<code>git checkout</code>的切换分支功能。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 如果本地仓库或者本地远程跟踪分支有这个分支，则切成功，否则失败</span>
$ <span class="token function">git</span> switch <span class="token operator">&lt;</span>branch_name<span class="token operator">&gt;</span>
<span class="token comment"># 创建并切换到新分支</span>
$ <span class="token function">git</span> switch <span class="token parameter variable">-c</span> <span class="token operator">&lt;</span>branch_name<span class="token operator">&gt;</span>
<span class="token comment"># 重置分支，删除已存在的分支且重新创建，分支不存在也不会报错称</span>
$ <span class="token function">git</span> switch <span class="token parameter variable">-C</span> <span class="token operator">&lt;</span>branch_name<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>💡<code>git switch &lt;branch_name&gt;</code>替代<code>git checkout &lt;branch_name*&gt;</code></p></blockquote><blockquote><p>💡<code>git switch -c &lt;branch_name&gt;</code>替代<code>git checkout -b &lt;branch_name&gt;</code></p></blockquote><blockquote><p>💡<code>git switch -C &lt;branch_name&gt;</code>替代<code>git checkout -B &lt;branch_name&gt;</code></p></blockquote><blockquote><p>💡<code>git switch -</code>可以快速切换上一个分支，来回切换，与 <code>cd -</code>一样</p></blockquote><h3 id="git-remote" tabindex="-1"><a class="header-anchor" href="#git-remote" aria-hidden="true">#</a> git remote</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 显示远程仓库的名字</span>
$ <span class="token function">git</span> remote
<span class="token comment"># 显示远程仓库的名字及url</span>
$ <span class="token function">git</span> remote <span class="token parameter variable">-v</span>
<span class="token comment"># 查看本地远程跟踪分支与远程仓库中分支的同步情况</span>
$ <span class="token function">git</span> remote show <span class="token operator">&lt;</span>remote_name<span class="token operator">&gt;</span>
<span class="token comment"># 可以删除（在远程仓库中被删除的分支）对应的本地远程跟踪分支</span>
$ <span class="token function">git</span> remote prune <span class="token operator">&lt;</span>remote_name<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>💡<code>git remote show &lt;remote_name&gt;</code>：一般应用场景就是在<code>git fetch</code>之前查看一下分支同步情况</p></blockquote><blockquote><p>💡<code>git fetch —prune</code>与<code>git remote prune</code>的作用一样，实际上删除（远程仓库中被删除的分支）对应的本地远程跟踪分支。</p></blockquote><h3 id="git-rebase" tabindex="-1"><a class="header-anchor" href="#git-rebase" aria-hidden="true">#</a> git rebase</h3><h4 id="变基" tabindex="-1"><a class="header-anchor" href="#变基" aria-hidden="true">#</a> 变基</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">git</span> rebase <span class="token operator">&lt;</span>upstream_name<span class="token operator">&gt;</span>
<span class="token comment"># 当前分支为dev</span>
$ <span class="token function">git</span> rebase main
<span class="token comment"># 如果有冲突，解决冲突后继续编辑</span>
$ <span class="token function">git</span> rebase —continue
<span class="token comment"># 当前分支为main</span>
$ <span class="token function">git</span> merge dev
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3be447b3710a4a24a28374b260e41834~tplv-k3u1fbpfcp-watermark.image?" alt="rebase1.gif"></p><blockquote><p><code>git rebase &lt;upstream_name&gt;</code>做了什么？ <code>git rebase main</code>（<code>dev</code>）把<code>dev</code>分支的提交<strong>重放</strong>（重新应用）到<code>main</code>分支的顶部。</p></blockquote><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a36e36437ea64910a69d6c20aca33562~tplv-k3u1fbpfcp-watermark.image?" alt="1.rebase.drawio.export.png"></p><blockquote><p><code>git rebase --onto main server client</code>做了什么？ 对于这个指令，每次看到都头大，需要自己用文字描述一下，以方便理解</p></blockquote><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb566e559e5948609174d05ef026a960~tplv-k3u1fbpfcp-watermark.image?" alt="2.rebase.drawio.export.png"></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># newbase_name\\upstream_name\\branch_name既可以是分支名，也可以是commit_sha1_value</span>
$ <span class="token function">git</span> rebase <span class="token punctuation">[</span>--onto <span class="token operator">&lt;</span>newbase_name<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>upstream_name<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token punctuation">[</span>branch_name<span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>💡 如何理解上面这条指令各个参数是啥意思？列出具体指令来尝试讲解</p></blockquote><ol><li><p>场景及命令一：<br> 场景：假设<code>dev</code>是从<code>master</code>检出的分支，要在<code>dev</code>分支上变基，当前所在分支不是<code>dev</code>分支<br> 命令：<code>git rebase &lt;upstream_name&gt;</code>：<code>git rebase master</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 切换到dev分支</span>
<span class="token function">git</span> checkout dev
<span class="token comment"># rebase master，这个master是对应upstream_name；怎么理解这里的上游分支</span>
<span class="token comment"># 实际上就是dev是从master检出的，是dev的上游分支，依此来找到两个分支的交叉点</span>
<span class="token comment"># 把在dev分支上以这个交叉点为起点，以当前HEAD为终点（dev最新commit），把这两点之间的</span>
<span class="token comment"># commit在master分支顶部（最新commit），重新来一遍，得到一个新的dev分支。</span>
<span class="token function">git</span> rebase master
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>场景及命令二：<br> 场景：假设<code>dev</code>是从<code>master</code>检出的分支，要在<code>dev</code>分支上变基，当前所在分支不是<code>dev</code>分支<br> 命令：<code>git rebase &lt;upstream_name&gt; [branch_name]</code>：<code>git rebase master dev</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># git rebase master dev 是 git checkout dev + git rebase master 这两条命令的简写</span>
<span class="token comment"># 就是我先切到dev分支，再rebase master分支</span>
<span class="token function">git</span> rebase master dev
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>场景及命令三：<br> 场景：假设当前所在分支是<code>dev</code>分支，其本地远程跟踪分支是<code>origin/dev</code><br> 命令：<code>git rebase</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># git rebase 是 git rebase origin/dev 命令的简写</span>
<span class="token function">git</span> rebase
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>💡 简写的前提是</p><ol><li>当前不是<strong>detached headhead</strong>状态</li><li>当前分支有对应的本地远程跟踪分支（即上游分支）</li></ol></blockquote></li><li><p>场景及命令四：<br> 场景：<div align="left"><img width="300" height="200" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/432cd0f690a44c5fa9b5a033c53a8f72~tplv-k3u1fbpfcp-watermark.image?"></div> 命令：<code>git rebase --onto main server client</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 第一步：git checkout client</span>
<span class="token comment"># 第二步：找到client与其上游分支server的交叉点的之后的所有commit</span>
<span class="token comment"># 第三步：把这些commit基于--onto参数的值main顶部（最新的commit），重放这些commit</span>
<span class="token comment"># 理解分为两部分，第一部分找server client交叉之后的提交，</span>
<span class="token comment"># 第二部分，以--onto参数的值为基，重放这些提交</span>
<span class="token function">git</span> rebase <span class="token parameter variable">--onto</span> main server client
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>场景及命令五：<br> 场景：<code>master</code>分支,共 6 个提交，每个提交都创建一个<code>txt</code>文件 命令：<code>git rebase --onto HEAD~5 HEAD~3 HEAD</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 第一步：git checkout HEAD，处于detached headhead状态</span>
<span class="token comment"># 第二步：找到HEAD~3与HEAD之间所有的commit</span>
<span class="token comment"># 第三步：把这些commit基于HEAD~5，重放这些commit</span>
<span class="token comment"># 实际效果就是删除第2次与第3次提交</span>
<span class="token comment"># 可以从当前游离的head检出一个分支替代master，或者直接git branch -D master</span>
<span class="token function">git</span> rebase <span class="token parameter variable">--onto</span> HEAD~5 HEAD~3 HEAD
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1da45a8e6f444e5ca78b994b812705bb~tplv-k3u1fbpfcp-watermark.image?" alt="4.rebase.drawio.export.png"></p></li></ol><ul><li>应用场景 <ol><li>在合并分支前，不想分叉，可以先<code>rebase</code>目标分支，再合入目标分支</li><li>同步远程分支时，不使用<code>git pull</code>，使用<code>git fetch</code>，再使用<code>git rebase</code></li></ol></li></ul><blockquote><p>💡 共享分支：当一个分支会被<code>push</code>到远程仓库，且有可能其他人会进行<code>pull</code>操作时，这就是一个共享分支</p></blockquote><blockquote><p>💡 Do not rebase commits that exist outside your repository and that people may have based work on.</p></blockquote><blockquote><p>💡 <strong>永远、永远不要对一个共享分支进行变基</strong>。</p></blockquote><blockquote><p>💡 原因就是：<strong>变基操作的实质是丢弃一些现有的提交</strong>，然后相应地新建一些内容一样但实际上不同的提交。</p><p>💡 基于变基的本质，如果是多人协作对共享分支允许变基；假如 A 在本地变基操作后推到了远程共享的分支，同时也丢弃了一些现有的提交；</p><p>💡 而 B 在拉去远程共享分支时，由于依赖了之前 A 丢弃的提交，所以如果再 merge 后推送到远程，就会造成重复的提交。</p><p>💡 解决方式：那就是永远不要对共享分支进行变基；</p></blockquote><h4 id="交互式变基" tabindex="-1"><a class="header-anchor" href="#交互式变基" aria-hidden="true">#</a> 交互式变基</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># start_commit_sha1_value不包含，end_commit_sha1_value包含</span>
<span class="token comment"># end_commit_sha1_value可以没有，则默认为当前分支的HEAD</span>
$ <span class="token function">git</span> rebase <span class="token parameter variable">-i</span> <span class="token punctuation">[</span>start_commit_sha1_value<span class="token punctuation">]</span> <span class="token punctuation">[</span>end_commit_sha1_value<span class="token punctuation">]</span>
<span class="token comment"># 如果你异常退出了变基选择操作的窗口，使用以下命令重新打开</span>
$ <span class="token function">git</span> rebase --edit-todo
<span class="token comment"># 放弃变基</span>
$ <span class="token function">git</span> rebase <span class="token parameter variable">--abort</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 保留，啥也不动</span>
**p, pick <span class="token operator">&lt;</span>commit<span class="token operator">&gt;</span> <span class="token operator">=</span> use commit**
<span class="token comment"># 只修改提交信息</span>
**r, reword <span class="token operator">&lt;</span>commit<span class="token operator">&gt;</span> <span class="token operator">=</span> use commit, but edit the commit message**
<span class="token comment"># 不只是修改提交信息</span>
**e, edit <span class="token operator">&lt;</span>commit<span class="token operator">&gt;</span> <span class="token operator">=</span> use commit, but stop <span class="token keyword">for</span> amending**
<span class="token comment"># 并入前一个提交</span>
**s, squash <span class="token operator">&lt;</span>commit<span class="token operator">&gt;</span> <span class="token operator">=</span> use commit, but meld into previous commit**
<span class="token comment"># 并入前一个提交，并丢弃该提交信息</span>
**f, fixup <span class="token punctuation">[</span>-C <span class="token operator">|</span> -c<span class="token punctuation">]</span> <span class="token operator">&lt;</span>commit<span class="token operator">&gt;</span> <span class="token operator">=</span> like <span class="token string">&quot;squash&quot;</span>
       but keep only the previous commit<span class="token string">&#39;s log message,
       unless -C is used,in which case keep only this commit&#39;</span>s message<span class="token punctuation">;</span>
       <span class="token parameter variable">-c</span> is same as <span class="token parameter variable">-C</span> but opens the editor
<span class="token comment"># 删除该提交</span>
**d, drop <span class="token operator">&lt;</span>commit<span class="token operator">&gt;</span> <span class="token operator">=</span> remove commit**
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>建议使用<code>vscode</code>中的<code>GitLens</code>插件来进行交互式变基，如下图 <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d80244a5064d40559bd0ace8df443b1f~tplv-k3u1fbpfcp-watermark.image?" alt="6.png"></p><h3 id="git-fetch" tabindex="-1"><a class="header-anchor" href="#git-fetch" aria-hidden="true">#</a> git fetch</h3><p>会拉去数据，同时会同步所有<strong>远程仓库分支</strong>和<strong>本地远程跟踪分支</strong>，对于本地远程跟踪分支，实际上就是为了区分本地仓库分支，前面加了<code>remote_name</code>的分支引用</p><p>💡<code>git fetch</code> 命令做了什么？</p><ol><li>拉取它的所有数据</li><li>更新你的远程跟踪分支</li><li>对与远程仓库中有而本地没有的分支，只会创建远程跟踪分支，不会创建本地分支</li></ol><p>💡 <strong>当抓取到新的远程跟踪分支时(这句话的意思是比如远程仓库新建了一个分支 dev，当<code>git fetch</code>时就会拉取新远程分支到本地的远程跟踪分支<code>origin/dev</code>)，但不会创建一个本地<code>dev</code>分支</strong>。</p><ol><li>如何只是想合并到你的分支，可以执行<code>git merge origin/dev</code></li><li>如果想在本地分支的工作，可以从<code>origin/dev</code>检出一个本地的<code>dev</code>分支,执行<code>git checkout -b dev origin/dev</code></li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 从远程仓库中拉去所有分支数据到本地，同步所有远程仓库分支和本地远程跟踪分支，如果缺省远程仓库名，默认为origin</span>
$ <span class="token function">git</span> fetch <span class="token operator">&lt;</span>remote_name<span class="token operator">&gt;</span>
<span class="token comment"># 从远程仓库中只拉取一个分支数据到本地</span>
$ <span class="token function">git</span> fetch <span class="token operator">&lt;</span>remote_name<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>remote_branch_name<span class="token operator">&gt;</span>
<span class="token comment"># 从远程仓库中只拉取一个分支数据到本地，并在本地仓库中创建一个分支</span>
$ <span class="token function">git</span> fetch <span class="token operator">&lt;</span>remote_name<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>remote_branch_name<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>local_branch_name<span class="token operator">&gt;</span>
<span class="token comment"># 首先会同步远程仓库分支与本地远程跟踪分支，同时会将本地远程跟踪分支中存在而远程仓库分支没有的分支删除。</span>
$ <span class="token function">git</span> fetch —prune
<span class="token comment"># 显示fetch的详细信息</span>
$ <span class="token function">git</span> fetch <span class="token parameter variable">-v</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>💡<code>git fetch —prune</code>：比如初始状态时远程仓库分支和本地远程跟踪分支已经同步； 此时，在远程仓库中删除某个分支<code>a</code>，再使用<code>git fetch</code>时，本地远程跟踪分支中的分支<code>a</code>不会删除； 此场景下可以使用<code>git fetch —prune</code>，也可以使用<code>git remote prune &lt;remote_name&gt;</code></p></blockquote><ul><li>应用 <ol><li>应用一<br><code>git fetch origin master</code> //从远程<code>origin</code>仓库拉取<code>master</code>分支的数据，同时同步<strong>本地远程跟踪分支</strong> <code>master</code><code>git log -p master origin/master</code> //比较<strong>本地仓库</strong>的<code>master</code>分支和<strong>本地远程跟踪分支</strong><code>master</code>的区别<br><code>git merge origin/master</code> //将<strong>本地远程跟踪分支</strong>中的<code>master</code>分支合入<strong>本地仓库</strong>的<code>master</code>分支</li><li>应用二<br><code>git fetch origin master:temp</code> //从远程的<code>origin</code>仓库拉取<code>master</code>分支的数据，并在<strong>本地仓库</strong>中新建一个分支<code>temp</code><code>git diff temp</code> //比较<strong>本地仓库</strong>当前分支和<strong>本地仓库</strong><code>temp</code>分支的差别<br><code>git merge temp</code> //合并<strong>本地仓库</strong><code>temp</code>分支到<strong>本地仓库</strong><code>master</code>分支<br><code>git branch -d temp</code> //删除<strong>本地仓库</strong><code>temp</code>分支</li></ol></li></ul><h3 id="git-merge" tabindex="-1"><a class="header-anchor" href="#git-merge" aria-hidden="true">#</a> git merge</h3><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f2f5fb03b744697993a3dd769bae533~tplv-k3u1fbpfcp-watermark.image?" alt="1.merge.drawio.export.png"></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 默认采用fast forward</span>
$ <span class="token function">git</span> merge
<span class="token comment"># 采用fast forward</span>
$ <span class="token function">git</span> merge <span class="token parameter variable">-ff</span>
<span class="token comment"># 强行关闭fast forward</span>
<span class="token comment"># 个人觉得应用场景是：拉取远程分支，检出自己的分支上开发，然后push前rebase一下远程分支，提个pr,采用git merge --no--ff的方式merge到远程分支。</span>
$ <span class="token function">git</span> merge --no-ff
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li><code>fast forward</code>：这时候<code>bugfix</code>合入<code>master</code>是一次<code>fast forward</code></li><li><code>3 way merge</code></li></ol><blockquote><p>💡 如果已经分叉了，还想实现<code>fast-forward</code>的<code>merge</code>,可以使用<code>git rebase</code></p></blockquote><h3 id="git-pull" tabindex="-1"><a class="header-anchor" href="#git-pull" aria-hidden="true">#</a> git pull</h3><p><code>git fetch</code> + <code>git merge</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># git fetch + git merge</span>
$ <span class="token function">git</span> pull
<span class="token comment"># git pull的简写</span>
$ <span class="token function">git</span> pull <span class="token parameter variable">--merge</span>
<span class="token comment"># git fetch + git rebase</span>
$ <span class="token function">git</span> pull <span class="token parameter variable">--rebase</span>
<span class="token comment"># 显示详细信息</span>
$ <span class="token function">git</span> pull <span class="token parameter variable">-v</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="git-push" tabindex="-1"><a class="header-anchor" href="#git-push" aria-hidden="true">#</a> git push</h3><p>将本地仓库当前分支推出送远程分支</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 完整命令，对于没有设置上游的本地分支推送至远程采用的方法</span>
$ <span class="token function">git</span> push <span class="token operator">&lt;</span>remote_name<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>local_branch_name<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>remote_branch_name<span class="token operator">&gt;</span>
<span class="token comment"># 如果本地分支名和远程分支名一样的情况下，可以省略:&lt;remote_branch_name&gt;</span>
$ <span class="token function">git</span> push <span class="token operator">&lt;</span>remote_name<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>local_branch_name<span class="token operator">&gt;&gt;</span>
<span class="token comment"># 设置当前的分支的上游分支是</span>
$ <span class="token function">git</span> push —set-upstream <span class="token operator">&lt;</span>remote_name<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>remote_branch_name<span class="token operator">&gt;</span>
<span class="token comment"># git push -u origin是git push —set-upstream origin的简写</span>
$ <span class="token function">git</span> push <span class="token parameter variable">-u</span> <span class="token operator">&lt;</span>remote_name<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>remote_branch_name<span class="token operator">&gt;</span>
<span class="token comment"># 删除远程分支</span>
$ <span class="token function">git</span> push <span class="token operator">&lt;</span>remote_name<span class="token operator">&gt;</span> <span class="token parameter variable">-d</span> <span class="token operator">&lt;</span>remote_branch_name<span class="token operator">&gt;</span>
<span class="token comment"># 删除远程分支</span>
$ <span class="token function">git</span> push <span class="token operator">&lt;</span>remote_name<span class="token operator">&gt;</span> :<span class="token operator">&lt;</span>remote_branch_name<span class="token operator">&gt;</span>
<span class="token comment"># 推送某个标签</span>
$ <span class="token function">git</span> push <span class="token operator">&lt;</span>remote_name<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>tag_name<span class="token operator">&gt;</span>
<span class="token comment"># 一次性推送很多标签</span>
$ <span class="token function">git</span> push origin —tags
<span class="token comment"># 删除远程标签的方式</span>
$ <span class="token function">git</span> push origin <span class="token parameter variable">--delete</span> <span class="token operator">&lt;</span>tag_name<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>💡<code>git push</code>简写命令使用前提条件是：</p><ol><li><strong>远程仓库有这个分支</strong></li><li>并且通过<code>git branch -vv</code>查看，<strong>本地仓库当前分支与本地远程跟踪分支是关联的</strong></li><li><strong>并且当前只有一个<code>origin</code>的<code>remote</code></strong></li></ol></blockquote><blockquote><p>💡<code>git push &lt;remote_name&gt; &lt;local_branch_name&gt;</code>：将本地仓库分支推送到远程仓库；这样操作，虽然会同时更新本地远程跟踪分支；并没有将本地的该分支与对应的本地远程跟踪分支进行关联（通过<code>git branch -vv</code>查看）</p></blockquote><blockquote><p>💡 新建本地分支后<code>push</code>到远程仓库，但并没有将本地分支与对应的本地远程跟踪分支相关联，下次本地分支有新的<code>commit</code>后，再<code>push</code>到远程，依然要<code>git push &lt;remote_name&gt; &lt;local_branch_name&gt;</code>，不能直接用<code>git push</code>这样的简写命令</p></blockquote><blockquote><p>💡<code>git push -u &lt;remote_name&gt; &lt;remote_branch_name&gt;</code>：将新建的本地分支推送到远程分支，并将该分支与对应的本地远程跟踪分支相关联，下回再推送时就可以使用<code>git push</code>这样的简写</p></blockquote><h3 id="git-revert" tabindex="-1"><a class="header-anchor" href="#git-revert" aria-hidden="true">#</a> git revert</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> revert <span class="token operator">&lt;</span>commit_sha1_value<span class="token operator">&gt;</span>
<span class="token function">git</span> revert HEAD
<span class="token function">git</span> revert HEAD^
<span class="token function">git</span> revert HEAD~
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下图是在<code>C5</code>为当前<code>HEAD</code>，分别对<code>C5</code>、<code>C4</code>、<code>C3</code>、<code>C2</code>、<code>C1</code>、<code>C0</code>进行<code>revert</code><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a55adbc6497c487d8df0ba0c4bce3af8~tplv-k3u1fbpfcp-watermark.image?" alt="1.revert.drawio.export.png"></p><blockquote><p>💡<strong>区别：<code>HEAD^</code>主要是控制<code>merge</code>之后回退的方向；<code>HEAD~</code>才是回退的步数</strong> &gt; <strong>个人理解：如果某个节点只有一个父节点，那就用<code>~</code>，不要用<code>^</code>,因为不太直观，容易混乱；只针对有多个父节点的回退操作采用<code>^</code>。</strong></p></blockquote><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> revert <span class="token parameter variable">-m</span> <span class="token operator">&lt;</span>commit_sha1_value<span class="token operator">&gt;</span>
<span class="token function">git</span> revert <span class="token parameter variable">-m</span> HEAD
<span class="token function">git</span> revert <span class="token parameter variable">-m</span> HEAD^
<span class="token function">git</span> revert <span class="token parameter variable">-m</span> HEAD~
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>💡revert 主要分两类，一类是针对只有一个父节点的 commit,一类是针对有两个父节点的 commit（merge 分支产生的）</p></blockquote><blockquote><p>💡<strong>什么时候加-m，当该节点是 merge 产生的节点的时候，它会有 2 个父节点（之前老是记不清，一个 commit 节点是不可能有多于 2 个父节点的，通过这个-m 的参数才想起来，所以这个-m 后面跟的数字只能是 1 和 2，1 代表我保留自己的分支，2 代表保留合入的分支）</strong></p></blockquote><blockquote><p>💡<code>revert</code>可能带来的问题如下图描述</p></blockquote><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7f592ef64fc4d4ab7a5759ae427c78c~tplv-k3u1fbpfcp-watermark.image?" alt="2.revert.drawio.export.png"></p><p>对于此问题官网给出的解决方案是在<code>master</code>上<code>revert</code>掉之前的<code>revert</code>,然后再<code>merge</code></p><h3 id="git-reset" tabindex="-1"><a class="header-anchor" href="#git-reset" aria-hidden="true">#</a> git reset</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 更改HEAD和当前分支顶部指向哪个commit，并覆盖暂存区</span>
<span class="token function">git</span> reset —mixed <span class="token operator">&lt;</span>commit_sha1_value<span class="token operator">&gt;</span>
<span class="token comment"># 只更改HEAD和当前分支顶部指向哪个commit</span>
<span class="token function">git</span> reset —soft <span class="token operator">&lt;</span>commit_sha1_value<span class="token operator">&gt;</span>
<span class="token comment"># 更改HEAD和当前分支顶部指向哪个commit，并覆盖暂存区和工作区</span>
<span class="token function">git</span> reset —hard <span class="token operator">&lt;</span>commit_sha1_value<span class="token operator">&gt;</span>
<span class="token comment"># git reset —mixed &lt;commit_sha1_value&gt;简写</span>
<span class="token function">git</span> reset <span class="token operator">&lt;</span>commit_sha1_value<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>git reset —soft</code></p><div align="left"><img width="400" height="200" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/597bb9988d7446f5b821193f67ccd368~tplv-k3u1fbpfcp-watermark.image?"></div><p><code>git reset —mixed</code></p><div align="left"><img width="400" height="200" src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d75cdff6a8345a088f22570de3b372e~tplv-k3u1fbpfcp-watermark.image?"></div><p><code>git reset —hard</code></p><div align="left"><img width="400" height="200" src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/497a731ab2134e638dadadfa8ba6812a~tplv-k3u1fbpfcp-watermark.image?"></div><p>下图是在<code>C5</code>为当前<code>HEAD</code>，分别<code>reset</code>到<code>C4</code>、<code>C3</code>、<code>C2</code>、<code>C1</code>、<code>C0</code>可以使用的命令 <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbc067b8635c4c8993cf64573037808f~tplv-k3u1fbpfcp-watermark.image?" alt="1.reset.drawio.export.png"></p><blockquote><p>💡 <code>revert</code>与<code>reset</code>的区别是什么<br><code>git revert</code>是用一次新的<code>commit</code>来回滚之前的<code>commit</code>，此次提交之前的<code>commit</code>都会被保留；<code>git reset</code>是回退到某次提交，提交及之前的<code>commit</code>都会被保留，但是此之后的<code>commit</code>都会被删除；所以可以说<code>revert</code>是以新增<code>commit</code>的方式<strong>回滚某个</strong><code>commit</code>；而<code>reset</code>是<strong>回退到</strong>某个<code>commit</code></p><p>💡 单从用法上来讲，应用场景可以参考以下： 找出有问题的<code>commit</code>，如果从 HEAD 一直到有问题的<code>commit</code>之间都不要，那就用<code>reset</code>；如果从<code>HEAD</code>一直到有问题的<code>commit</code>之间，只想回滚有问题的<code>commit</code>，中间其他的<code>commit</code>还要保留，那就用<code>revert</code></p><p>💡 以上过于啰嗦了，简单点，就是<strong>回滚某个</strong><code>commit</code>用<code>revert</code>，<strong>回退到</strong>某个<code>commit</code>用<code>reset</code>；所以对于<code>git reset HEAD</code>这个命令是无意义的，当前就在这个<code>commit</code>，要回退到这个<code>commit</code>岂不是无用功；对于<code>git revert HEAD</code>这个命令是有意义的，如果你确实想回滚当前的<code>commit</code></p></blockquote><h3 id="git-stash" tabindex="-1"><a class="header-anchor" href="#git-stash" aria-hidden="true">#</a> git stash</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 保存工作区暂存区中的内容</span>
<span class="token function">git</span> stash
<span class="token comment"># 保存工作区暂存区中的内容，并添加注释，不推荐使用</span>
<span class="token function">git</span> stash save <span class="token string">&#39;message&#39;</span>
<span class="token comment"># 保存工作区暂存区中的内容，并添加注释，推荐使用</span>
<span class="token function">git</span> stash push <span class="token parameter variable">-m</span> <span class="token string">&#39;message&#39;</span>
<span class="token comment"># 恢复后同时弹出 stash</span>
<span class="token function">git</span> stash pop
<span class="token comment"># 恢复后stash内容并不删除</span>
<span class="token function">git</span> stash apply
<span class="token comment"># 删除stash</span>
<span class="token function">git</span> stash drop
<span class="token comment"># 清空\`stash\`</span>
<span class="token function">git</span> stash <span class="token function">clear</span>
<span class="token comment"># 显示所有的stash</span>
<span class="token function">git</span> stash list
<span class="token comment"># 显示最新缓存修改的统计信息</span>
<span class="token function">git</span> stash show
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>💡 在使用<code>git stash pop</code>代码时，经常会碰到有冲突的情况，一旦出现冲突的话，系统会认为你的<code>stash</code>没有结束。导致的结果是<code>git stash list</code> 中的列表依然存在，实际上代码已经<code>pop</code>出来了。</p></blockquote><ul><li>应用场景 <ol><li>正常 dev 分支上开发，紧急 bug 或者功能来时，可以先将在 dev 分支做的工作用<code>git stash save</code>存下，然后切换到紧急分支，修复或者完成<code>commit</code>之后，在切回 dev 分支，用<code>git stash pop</code>将之前的工作内容回复</li></ol></li></ul><h2 id="git-中的其他概念及指令" tabindex="-1"><a class="header-anchor" href="#git-中的其他概念及指令" aria-hidden="true">#</a> Git 中的其他概念及指令</h2><h3 id="本地远程跟踪分支-上游分支" tabindex="-1"><a class="header-anchor" href="#本地远程跟踪分支-上游分支" aria-hidden="true">#</a> 本地远程跟踪分支 上游分支</h3><p>从一个远程跟踪分支检出一个本地分支会自动创建所谓的<strong>跟踪分支</strong>（它跟踪的分支叫做<strong>上游分支</strong>，即跟踪的是远程仓库的分支）； 跟踪分支是与远程分支有直接关系的本地分支； 如果在一个跟踪分支上输入 <code>git pull</code>，<code>Git</code> 能自动地识别去哪个服务器上抓取、合并到哪个分支。</p><h3 id="orig-head" tabindex="-1"><a class="header-anchor" href="#orig-head" aria-hidden="true">#</a> ORIG_HEAD</h3><p><code>ORIG_HEAD</code> 记录了<code>reset</code>或者<code>merge</code>操作之前的<code>HEAD</code></p><p>应用场景：</p><ol><li>利用<code>ORIG_HEAD</code>撤销<code>reset</code>：<code>git reset ORIG_HEAD</code></li><li>利用<code>ORIG_HEAD</code>撤销<code>merge</code>：<code>git reset --merge ORIG_HEAD</code></li></ol><blockquote><p>use --merge flag to preserve any uncommitted changes</p></blockquote><h3 id="fetch-head" tabindex="-1"><a class="header-anchor" href="#fetch-head" aria-hidden="true">#</a> FETCH_HEAD</h3><p>记录了远程所有分支对应的最新的<code>commit</code></p><h3 id="git-ls-files-s" tabindex="-1"><a class="header-anchor" href="#git-ls-files-s" aria-hidden="true">#</a> git ls-files -s</h3><p>查看索引区内容</p><h3 id="git-cat-file" tabindex="-1"><a class="header-anchor" href="#git-cat-file" aria-hidden="true">#</a> git cat-file</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看git object内容</span>
<span class="token function">git</span> cat-file <span class="token parameter variable">-p</span> <span class="token operator">&lt;</span>sha1_value<span class="token operator">&gt;</span>
<span class="token comment"># 查看git object类型</span>
<span class="token function">git</span> cat-file <span class="token parameter variable">-t</span> <span class="token operator">&lt;</span>sha1_value<span class="token operator">&gt;</span>
<span class="token comment"># 查看git object大小</span>
<span class="token function">git</span> cat-file <span class="token parameter variable">-s</span> <span class="token operator">&lt;</span>sha1_value<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="git-objects" tabindex="-1"><a class="header-anchor" href="#git-objects" aria-hidden="true">#</a> git objects</h3><p>有四种类型：<code>blob</code>、<code>commit</code>、<code>tree</code>、<code>tag</code></p><p>通用数据结构为：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9a6f5b4f0ef4735a4259521deb2ca5b~tplv-k3u1fbpfcp-watermark.image?" alt="1.git-object.drawio.export.png"></p><h4 id="blob" tabindex="-1"><a class="header-anchor" href="#blob" aria-hidden="true">#</a> blob</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># echo -n输出的内容不换行</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-n</span> <span class="token string">&#39;Hello, World!&#39;</span> <span class="token operator">|</span> <span class="token function">git</span> hash-object <span class="token parameter variable">--stdin</span>
b45ef6fec89518d314f546fd6c3025367b721684
<span class="token comment"># echo -e转义</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token parameter variable">-n</span> <span class="token string">&#39;blob 13\\0Hello, World!&#39;</span> <span class="token operator">|</span> openssl sha1
<span class="token punctuation">(</span>stdin<span class="token punctuation">)</span><span class="token operator">=</span> b45ef6fec89518d314f546fd6c3025367b721684
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>git add .</code>会生成<code>blob</code>对象</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11c83d7412d343689b4f749484eddde0~tplv-k3u1fbpfcp-watermark.image?" alt="1.blobdrawio.export.png"></p><p><code>blob</code>对象存储文件内容信息，包含<code>sha1</code>、字节大小、文件内容数据</p><h4 id="tree" tabindex="-1"><a class="header-anchor" href="#tree" aria-hidden="true">#</a> tree</h4><p><code>git commit</code>会生成<code>tree</code>对象（可能有多个）</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0ac9f1785b8342c18f387176eb07bb00~tplv-k3u1fbpfcp-watermark.image?" alt="1.tree.drawio.export.png"></p><p><code>tree</code>对象中嵌套<code>tree</code>以来表示文件的嵌套</p><blockquote><p>💡 <code>blob</code>对象不存储文件的名称，文件的名称存储在<code>tree</code>对象中</p></blockquote><h4 id="commit" tabindex="-1"><a class="header-anchor" href="#commit" aria-hidden="true">#</a> commit</h4><p><code>git commit</code>会生成一个<code>commit</code>对象（包含）、<code>tree</code>对象（可有有多个），不会生成<code>blob</code>对象</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29cf0fd7abd042fb9588f172d07770b8~tplv-k3u1fbpfcp-watermark.image?" alt="1.commit.drawio.export.png"></p><h4 id="tag" tabindex="-1"><a class="header-anchor" href="#tag" aria-hidden="true">#</a> tag</h4><p><code>git tag -a tagname</code>会创建一个<code>tag</code>对象，对象中的<code>object</code>会指向某一个<code>commit</code>；<code>tag</code>对象会包含一些作者和时间的信息等等</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f836a36047e4b35adc522b222278922~tplv-k3u1fbpfcp-watermark.image?" alt="1.tag.drawio.export.png"></p><blockquote><p>💡 <code>git tag &lt;tag_name&gt;</code>不会创建一个<code>tag</code>类型的<code>git object</code></p></blockquote><h3 id="git-references" tabindex="-1"><a class="header-anchor" href="#git-references" aria-hidden="true">#</a> git references</h3><p>git 中的引用实际上是指向某个 commit 的指针</p><h4 id="tags" tabindex="-1"><a class="header-anchor" href="#tags" aria-hidden="true">#</a> Tags</h4><p><code>Lightweight tags</code>的引用是指向某个<code>commit</code>类型的<code>git object</code>对象的指针</p><p><code>ANNOTATED tags</code>的引用时指向某个<code>tag</code>类型的<code>git object</code>对象的指针</p><h4 id="branches" tabindex="-1"><a class="header-anchor" href="#branches" aria-hidden="true">#</a> Branches</h4><p><code>Branches</code>的引用是指向某个<code>commit</code>类型的<code>git object</code>对象的指针</p><h4 id="head" tabindex="-1"><a class="header-anchor" href="#head" aria-hidden="true">#</a> HEAD</h4><p>通常是指向当前分支的引用，但是它也可以指向某个<code>commit</code>类型的<code>git object</code>对象（<code>detached HEAD</code>）</p><h3 id="git-show-ref" tabindex="-1"><a class="header-anchor" href="#git-show-ref" aria-hidden="true">#</a> git show-ref</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看当前所有的tag，约等同与 git tag</span>
<span class="token function">git</span> show-ref <span class="token parameter variable">--tags</span>
<span class="token comment"># 查看当前所有的分支，约等同与 git branch</span>
<span class="token function">git</span> show-ref <span class="token parameter variable">--heads</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="git-gc" tabindex="-1"><a class="header-anchor" href="#git-gc" aria-hidden="true">#</a> git gc</h3><p>由于<code>git</code>是全量快照，每一次<code>commit</code>都会对应一个版本的全部数据，这样会造成仓库很大，为了解决该问题，引入了压缩算法，举例，<code>git clone</code>在拉取远程仓库时，就会压缩成<code>pack</code>后再传递；在本地执行<code>gc</code>后，也会把<code>.git/objects</code>文件夹下的对象压缩到<code>pack</code>文件夹下。</p><h2 id="参考文献" tabindex="-1"><a class="header-anchor" href="#参考文献" aria-hidden="true">#</a> 参考文献</h2>`,199),g={href:"https://git-scm.com/book/en/v2",target:"_blank",rel:"noopener noreferrer"},b={href:"https://frontendmasters.com/courses/git-in-depth/",target:"_blank",rel:"noopener noreferrer"},v=e("blockquote",null,[e("p",null,[n("本文发布内容来自个人对于"),e("strong",null,"Git-scm"),n("网站关于"),e("strong",null,"Pro Git book"),n("的阅读及实践后的理解，同时参考了"),e("strong",null,"Git In-depth"),n("视频，文章未经授权禁止任何形式的转载。")])],-1);function h(k,f){const a=o("ExternalLinkIcon");return c(),i("div",null,[d,e("p",null,[n("本文主要讲"),p,n("的相关知识，特别是关于 rebase、revert 指令的一些个人理解，欢迎大家指正。"),e("a",m,[n("articles/2023-03-14-GIt 时光机（简单小例子）.md at main · slshsl/articles (github.com)"),s(a)])]),u,e("ul",null,[e("li",null,[e("a",g,[n("Git - Book (git-scm.com)"),s(a)])]),e("li",null,[e("a",b,[n("Git In-depth"),s(a)])])]),v])}const x=t(r,[["render",h],["__file","Git shiguangji，yizhidiaopidemiao.html.vue"]]);export{x as default};
